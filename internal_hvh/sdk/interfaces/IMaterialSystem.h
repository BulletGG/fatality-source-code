#pragma once

typedef unsigned short MaterialHandle_t;

struct MaterialVideoMode_t
{
	int m_Width;
	int m_Height;
	int m_Format;
	int m_RefreshRate;
};

struct MaterialSystem_Config_t
{
	MaterialVideoMode_t m_VideoMode;
	float m_fMonitorGamma;
	float m_fGammaTVRangeMin;
	float m_fGammaTVRangeMax;
	float m_fGammaTVExponent;
	bool m_bGammaTVEnabled;
	bool m_bTripleBuffered;
	int m_nAASamples;
	int m_nForceAnisotropicLevel;
	int m_nSkipMipLevels;
	int m_nDxSupportLevel;
	int m_nFlags;
	bool m_bEditMode;
	char m_nProxiesTestMode;
	bool m_bCompressedTextures;
	bool m_bFilterLightmaps;
	bool m_bFilterTextures;
	bool m_bReverseDepth;
	bool m_bBufferPrimitives;
	bool m_bDrawFlat;
	bool m_bMeasureFillRate;
	bool m_bVisualizeFillRate;
	bool m_bNoTransparency;
	bool m_bSoftwareLighting;
	bool m_bAllowCheats;
	char m_nShowMipLevels;
	bool m_bShowLowResImage;
	bool m_bShowNormalMap;
	bool m_bMipMapTextures;
	char m_nFullbright;
	bool m_bFastNoBump;
	bool m_bSuppressRendering;
	bool m_bDrawGray;
	bool m_bShowSpecular;
	bool m_bShowDiffuse;
	int m_nWindowedSizeLimitWidth;
	int m_nWindowedSizeLimitHeight;
	int m_nAAQuality;
	bool m_bShadowDepthTexture;
	bool m_bMotionBlur;
	bool m_bSupportFlashlight;
	bool m_bPaintEnabled;
	char pad[ 0xC ];
};

enum RenderTargetSizeMode_t
{
	RT_SIZE_NO_CHANGE = 0,			// Only allowed for render targets that don't want a depth buffer
	// (because if they have a depth buffer, the render target must be less than or equal to the size of the framebuffer).
	RT_SIZE_DEFAULT = 1,				// Don't play with the specified width and height other than making sure it fits in the framebuffer.
	RT_SIZE_PICMIP = 2,				// Apply picmip to the render target's width and height.
	RT_SIZE_HDR = 3,					// frame_buffer_width / 4
	RT_SIZE_FULL_FRAME_BUFFER = 4,	// Same size as frame buffer, or next lower power of 2 if we can't do that.
	RT_SIZE_OFFSCREEN = 5,			// Target of specified size, don't mess with dimensions
	RT_SIZE_FULL_FRAME_BUFFER_ROUNDED_UP = 6 // Same size as the frame buffer, rounded up if necessary for systems that can't do non-power of two textures.
};

enum MaterialRenderTargetDepth_t
{
	MATERIAL_RT_DEPTH_SHARED = 0x0,
	MATERIAL_RT_DEPTH_SEPARATE = 0x1,
	MATERIAL_RT_DEPTH_NONE = 0x2,
	MATERIAL_RT_DEPTH_ONLY = 0x3,
};

enum CompiledVtfFlags
{
	// Flags from the *.txt config file
	TEXTUREFLAGS_POINTSAMPLE = 0x00000001,
	TEXTUREFLAGS_TRILINEAR = 0x00000002,
	TEXTUREFLAGS_CLAMPS = 0x00000004,
	TEXTUREFLAGS_CLAMPT = 0x00000008,
	TEXTUREFLAGS_ANISOTROPIC = 0x00000010,
	TEXTUREFLAGS_HINT_DXT5 = 0x00000020,
	TEXTUREFLAGS_PWL_CORRECTED = 0x00000040,
	TEXTUREFLAGS_NORMAL = 0x00000080,
	TEXTUREFLAGS_NOMIP = 0x00000100,
	TEXTUREFLAGS_NOLOD = 0x00000200,
	TEXTUREFLAGS_ALL_MIPS = 0x00000400,
	TEXTUREFLAGS_PROCEDURAL = 0x00000800,

	// These are automatically generated by vtex from the texture data.
	TEXTUREFLAGS_ONEBITALPHA = 0x00001000,
	TEXTUREFLAGS_EIGHTBITALPHA = 0x00002000,

	// Newer flags from the *.txt config file
	TEXTUREFLAGS_ENVMAP = 0x00004000,
	TEXTUREFLAGS_RENDERTARGET = 0x00008000,
	TEXTUREFLAGS_DEPTHRENDERTARGET = 0x00010000,
	TEXTUREFLAGS_NODEBUGOVERRIDE = 0x00020000,
	TEXTUREFLAGS_SINGLECOPY = 0x00040000,

	TEXTUREFLAGS_SRGB = 0x00080000, //SRGB correction has already been applied to this texture.

	TEXTUREFLAGS_DEFAULT_POOL = 0x00100000, // Nvidia Stereo Change: Water (Force a texture to the default pool)

	TEXTUREFLAGS_COMBINED = 0x00200000,

	TEXTUREFLAGS_ASYNC_DOWNLOAD = 0x00400000,

	TEXTUREFLAGS_NODEPTHBUFFER = 0x00800000,

	TEXTUREFLAGS_SKIP_INITIAL_DOWNLOAD = 0x01000000, // Skip initial download when creating a procedural texture

	TEXTUREFLAGS_CLAMPU = 0x02000000,
	TEXTUREFLAGS_VERTEXTEXTURE = 0x04000000,	// Usable as a vertex texture
	TEXTUREFLAGS_SSBUMP = 0x08000000,

	TEXTUREFLAGS_MOST_MIPS = 0x10000000, // Don't load the bottom few mips at runtime

	TEXTUREFLAGS_BORDER = 0x20000000,	// Clamp to border color on all texture coordinates

	TEXTUREFLAGS_UNUSED_40000000 = 0x40000000,
	TEXTUREFLAGS_UNUSED_80000000 = 0x80000000,
};

#define CREATERENDERTARGETFLAGS_HDR				0x00000001
#define CREATERENDERTARGETFLAGS_AUTOMIPMAP		0x00000002
#define CREATERENDERTARGETFLAGS_UNFILTERABLE_OK 0x00000004
// XBOX ONLY:
#define CREATERENDERTARGETFLAGS_NOEDRAM			0x00000008 // inhibit allocation in 360 EDRAM
#define CREATERENDERTARGETFLAGS_TEMP			0x00000010 // only allocates memory upon first resolve, destroyed at level end
#define CREATERENDERTARGETFLAGS_ALIASCOLORANDDEPTHSURFACES 0x00000020 // force the depth surface to be aliased overtop of the color surface in EDRAM, for the special case of depth-only rendering

class IMatRenderContext;
class ITexture;
class IMaterialSystem
{
public:
	VFUNC( 21, OverrideConfig( const MaterialSystem_Config_t& cfg, bool b ), bool( __thiscall* )( void*, const MaterialSystem_Config_t&, bool ) )( cfg, b )
		VFUNC( 36, GetBackBufferFormat(), ImageFormat( __thiscall* )( void* ) )( )
		VFUNC( 83, CreateMaterial( const char* name, KeyValues* kv ), IMaterial* ( __thiscall* )( void*, const char*, KeyValues* ) )( name, kv )
		VFUNC( 84, FindMaterial( const char* name, const char* texgroup, bool complain = true, const char* complainprefix = nullptr ), IMaterial* ( __thiscall* )( void*, const char*, const char*, bool, const char* ) )( name, texgroup, complain, complainprefix )
		VFUNC( 86, FirstMaterial(), MaterialHandle_t( __thiscall* )( void* ) )( )
		VFUNC( 87, NextMaterial( MaterialHandle_t h ), MaterialHandle_t( __thiscall* )( void*, MaterialHandle_t ) )( h )
		VFUNC( 88, InvalidMaterial(), MaterialHandle_t( __thiscall* )( void* ) )( )
		VFUNC( 89, GetMaterial( MaterialHandle_t h ), IMaterial* ( __thiscall* )( void*, MaterialHandle_t ) )( h )
		VFUNC( 90, GetNumMaterials(), int( __thiscall* )( void* ) )( )
		VFUNC( 91, FindTexture( const char* name, const char* groupname, bool complain = true, int nAdditionalCreationFlags = 0 ), ITexture* ( __thiscall* )( void*, const char*, const char*, bool, int ) )( name, groupname, complain, nAdditionalCreationFlags )
		VFUNC( 94, BeginRenderTargetAllocation(), void( __thiscall* )( void* ) )( )
		VFUNC( 95, EndRenderTargetAllocation(), void( __thiscall* )( void* ) )( )
		VFUNC( 136, FinishRenderTargetAllocation(), void( __thiscall* )( void* ) )( )
		VFUNC( 115, GetRenderContext(), IMatRenderContext* ( __thiscall* )( void* ) )( )
		VFUNC( 97, CreateNamedRenderTargetTextureEx( const char* name, int w, int h, RenderTargetSizeMode_t size_mode, ImageFormat format, MaterialRenderTargetDepth_t depth = MATERIAL_RT_DEPTH_SHARED, unsigned int texture_flags = TEXTUREFLAGS_CLAMPS | TEXTUREFLAGS_CLAMPT, unsigned int render_target_flags = 0 ),
		ITexture* ( __thiscall* )( void*, const char*, int, int, RenderTargetSizeMode_t, ImageFormat, MaterialRenderTargetDepth_t, unsigned int, unsigned int ) )( name, w, h, size_mode, format, depth, texture_flags, render_target_flags )
		ITexture* CreateRenderTarget( const char* name, int w, int h )
	{
		return CreateNamedRenderTargetTextureEx( name, w, h, RT_SIZE_DEFAULT, GetBackBufferFormat(), MATERIAL_RT_DEPTH_SHARED, TEXTUREFLAGS_CLAMPS | TEXTUREFLAGS_CLAMPT, CREATERENDERTARGETFLAGS_HDR );
	}

	OFFSET( DisableRenderTargetAllocationForever, bool, server_offset( sig_disable_render_target_allocation ) )

	void ForceBeginRenderTargetAllocation()
	{
		const bool old = DisableRenderTargetAllocationForever();

		DisableRenderTargetAllocationForever() = false;
		BeginRenderTargetAllocation();
		DisableRenderTargetAllocationForever() = old;
	}

	void ForceEndRenderTargetAllocation()
	{
		const bool old = DisableRenderTargetAllocationForever();

		DisableRenderTargetAllocationForever() = false;
		EndRenderTargetAllocation();
		DisableRenderTargetAllocationForever() = old;
	}
};
